# 卡尔曼滤波预测球轨迹

## python

``` python
from cv2 import cv2 as cv
import numpy as np

class KalmanFilter:#OPENCV的卡尔曼滤波只有四个方法；构造，初始化，预测，更新
    #构造
    kf = cv.KalmanFilter(4, 2)
    #初始化
    kf.measurementMatrix = np.array([[1, 0, 0, 0], [0, 1, 0, 0]], np.float32)
    kf.transitionMatrix = np.array([[1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0], [0, 0, 0, 1]], np.float32)

    def predict(self, coordX, coordY):
        '''预测目标对象位置'''
        measured = np.array([[np.float32(coordX)], [np.float32(coordY)]])
        #更新
        self.kf.correct(measured)
        #预测
        predicted = self.kf.predict()
        x, y = int(predicted[0]), int(predicted[1])
        return x, y

def contour_center(contour):
    M = cv.moments(contour)
    cX = int(M["m10"] / M["m00"])
    cY = int(M["m01"] / M["m00"])
    return cX,cY

cap = cv.VideoCapture(0)
kf=KalmanFilter()

red_min1 = np.array([150, 128, 46])
red_max1 = np.array([180, 255, 255])
red_min2 = np.array([0, 128, 46])
red_max2 = np.array([5, 255, 255])

while True:

    #基本处理
    ret, frame = cap.read()

    # if ret is False:
    #     break

    frame = cv.medianBlur(frame, 7)
    hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)

    red_binary1 = cv.inRange(hsv, red_min1, red_max1)
    red_binary2 = cv.inRange(hsv, red_min2, red_max2)
    red_binary = cv.bitwise_or(red_binary1, red_binary2)

    kernel = np.ones((5, 5), np.uint8)
    red_binary = cv.morphologyEx(red_binary, cv.MORPH_OPEN, kernel)
    red_contours, _ = cv.findContours(red_binary, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)

    #red_contours = sorted(red_contours, key=lambda x: cv.contourArea(x), reverse=True)  # 面积由大到小
    #red_contours=filter(lambda x: x<25000 and x>3000,red_contours)

    #这里使用的算法比起遍历所有轮廓速度更快

    red_contours=[x for x in red_contours if cv.contourArea(x)<25000 and cv.contourArea(x)>3000]
    red_contours = sorted(red_contours, key=lambda x: cv.contourArea(x), reverse=True)  # 面积由大到小
    cv.drawContours(frame,red_contours[0],-1,(0,0,0),5)#要最大的轮廓
    cx,cy=contour_center(red_contours[0])
    prediction = kf.predict(cx, cy)
    cv.circle(frame, (prediction[0], prediction[1]), 20, (255, 0, 0), 4)
    # cv.imshow("Frame", frame)
    # key = cv.waitKey(150)
    # if key == 27:
    #     break
```

